# 动态规划算法和贪心算法
## 两个算法的基本概念
  - 动态规划（Dynamic Programming, DP）是一种通过分解问题为子问题、存储子问题的解以避免重复计算的高效算法设计范式，其核心在于以下三个关键性质和基本组成要素
  - ​​贪心算法：每一步都选当前看起来最好的，希望通过局部最优拼出全局最优
### 动态规划:3个核心特点
  - ​​拆大问题为小问题​​：就像搭积木，把高楼分解成一层层小积木块。比如算"5层楼梯的走法"，先算1层、2层怎么走，再逐步算到5层
  - 记住算过的小问题​：准备一个笔记本（数组/字典），每次算完小积木块就记下来。比如算过"3层楼梯有3种走法"就记下，下次直接查不用重算
  - ​​小问题之间有规律​​ ：发现每层楼梯的走法 = 前1层走法 + 前2层走法。这就是递推公式：f(n) = f(n-1) + f(n-2)
  - demo：
  ```python
  dp = [0]*(n+1)
  dp[1] = 1  # 1层
  dp[2] = 2  # 2层
  for i in range(3, n+1):
    dp[i] = dp[i-1] + dp[i-2]
   ```
### 贪心算法:3个核心特点
- ​​短视选择​​：只关心眼前利益，比如找零钱时优先用最大面额的硬币（比如先给50元，再给20元），不管后面会不会有更优组合
- ​​不回头​​：一旦做出选择就不反悔，不像动态规划会保留多种可能性。比如导航选路时，贪心算法会直接走当前最快的路口，哪怕后面可能堵车
- ​​简单高效​​：适合一维问题（比如分糖果、排队问题），代码通常只有几行循环，计算速度快


## 两个算法区别和联系
动态规划的核心区别与特性

动态规划（Dynamic Programming, DP）与其他算法（尤其是贪心算法）的核心区别主要体现在以下方面：

---

1. **核心设计思想**  
动态规划通过分解问题为重叠子问题，并存储子问题的解（称为“记忆化”），避免重复计算，最终通过递推得到全局最优解。  
贪心算法则每一步只选择当前最优解，不考虑后续影响，可能导致无法得到全局最优解。

---

2. **适用场景**  
• 动态规划适用于满足以下条件的问题：  

  • 最优子结构：全局最优解包含子问题的最优解（例如背包问题、最长公共子序列）。  

  • 重叠子问题：子问题被多次重复计算（例如斐波那契数列、最短路径问题）。  

• 贪心算法仅需满足贪心选择性质（局部最优能推导全局最优），例如最小生成树、哈夫曼编码。


---

3. **实现方式对比**
---

| 特性       | 动态规划                     | 贪心算法                     |
|--------------|----------------------------|----------------------------|
| 解的质量   | 保证全局最优解            | 可能得到次优解（需问题特性支持） |
| 时间复杂度 | 较高（通常为O(n²)或更高）     | 较低（通常为O(n)或O(n log n)） |
| 空间复杂度 | 较高（需存储子问题的解）        | 较低（通常仅需常数空间）        |
| 回溯性     | 可回溯（通过存储的中间结果）     | 不可回溯（选择不可逆）         |
| 典型问题   | 背包问题、编辑距离、路径规划     | 最小生成树、活动选择、找零钱   | 



4. **关键差异举例**  
• 背包问题：  

  • 动态规划会考虑所有物品组合的可能解，通过二维表格存储子问题结果，最终找到最优解。  

  • 贪心算法可能直接按“单位价值最高”选择物品，但可能错过最优组合（例如无法处理物品不可分割的情况）。  

• 最短路径问题：  

  • 动态规划（如Floyd-Warshall算法）计算所有节点对的最短路径，时间复杂度为O(n³)，但保证准确性。  

  • 贪心算法（如Dijkstra算法）仅适用于无负权边的情况，且无法处理复杂依赖。


---

5. **总结**  
动态规划的核心优势在于系统性解决复杂问题，通过存储和复用子问题解确保全局最优；其代价是较高的计算和存储开销。  
与贪心算法相比，动态规划更适用于子问题有重叠且需全局优化的场景，而贪心算法适合局部最优可推导全局最优的简单问题。


## 两个算法分别在什么场景使用？重点讲解在电商和金融领域
贪心算法与动态规划算法对比及电商/金融场景应用

| 算法类型 | 核心原理                                                                 | 适用场景特点                                                                 | 电商领域应用场景                                                                                     | 金融领域应用场景                                                                                     |
|--------------|-----------------------------------------------------------------------------|---------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| 贪心算法 | 每一步选择当前最优解，不考虑全局最优性，但要求问题具有贪心选择性质和最优子结构 。 | 问题能通过局部最优叠加达到全局最优，且无后效性。时间复杂度低，适合实时决策场景。                                         | 1. 实时推荐系统：根据用户当前行为快速选择最优商品（如点击率最高的商品）。<br>2. 库存分配：优先分配高价值或紧俏商品，如秒杀活动库存分配。<br>3. 优惠券组合：基于用户当前购物车快速选择最优优惠组合（如满减叠加）。 | 1. 高频交易策略：快速选择当前收益最高的交易标的（如股票或期货）。<br>2. 快速止损决策：根据实时市场波动选择局部最优止损点。<br>3. 短期投资组合：在有限时间内选择收益最高的资产组合。 |
| 动态规划 | 通过分解子问题、存储中间结果（状态转移方程）和递推求解全局最优解，需满足最优子结构和重叠子问题 。 | 问题需全局最优解，子问题存在重复计算。时间/空间复杂度较高，适合离线或周期性优化场景。                                  | 1. 物流路径优化：计算多仓库协同配送的最优路径（如最小化运输成本）。<br>2. 促销策略规划：动态调整折扣力度以最大化长期利润（如考虑库存成本和用户购买行为）。<br>3. 库存动态管理：多周期库存补货策略优化（如考虑需求波动和仓储成本）。 | 1. 投资组合优化：长期资产配置中平衡风险与收益（如Markowitz模型）。<br>2. 期权定价：通过状态转移方程计算期权价值（如Black-Scholes模型）。<br>3. 风险模型构建：动态评估市场风险（如VaR计算）。 |

---

核心差异总结
| 对比维度       | 贪心算法                                                                 | 动态规划                                                                 |
|--------------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 最优解保证      | 局部最优，可能无法全局最优 。                                           | 全局最优（需满足最优子结构）。                                          |
| 时间复杂度      | 通常为O(n)或O(n log n)，适合实时处理 。                                 | 通常为O(n²)或更高，适合离线计算 。                                       |
| 空间复杂度      | 低（仅需存储当前状态）。                                               | 高（需存储中间状态表）。                                               |
| 典型问题        | 最小生成树（Prim算法）、背包问题（分数背包）、活动选择 。               | 背包问题（0-1背包）、最长公共子序列、最短路径（Floyd算法）。            |
| 适用领域侧重    | 实时性要求高、局部决策影响显著的场景（如电商秒杀、金融高频交易）。       | 需全局优化、多阶段决策的场景（如电商物流规划、金融长期投资）。         |

---

电商与金融场景深度解析
1. **电商场景**
• 贪心算法：  

  • 案例：在“双十一”大促中，系统需实时调整优惠券组合。贪心算法可快速筛选出当前用户购物车中“满500减100”叠加“品类券”的最优组合，而无需考虑后续可能的更高折扣。

  • 局限性：若优惠规则复杂（如跨品类满减），贪心策略可能错过全局最优解。


• 动态规划：  

  • 案例：物流中心需规划全国仓库的协同配送路径，动态规划通过状态转移方程计算各节点间的最短路径，结合实时交通数据更新策略。

  • 优势：在多约束（如车辆载重、时间窗口）下仍能保证全局最优。


2. **金融场景**
• 贪心算法：  

  • 案例：高频交易中，算法需在毫秒级选择当前市场最优报价（如最优买一价），贪心策略可快速匹配订单。

  • 风险：在极端市场波动下，局部最优可能导致连锁亏损。


• 动态规划：  

  • 案例：构建长期养老基金组合时，动态规划通过递归计算不同资产配比的风险-收益曲线，选择夏普比率最高的方案。

  • 扩展：结合蒙特卡洛模拟，动态规划可评估极端市场情景下的资产抗风险能力。


---

选择建议
• 优先贪心算法：当问题满足贪心性质、实时性要求高且允许次优解时（如电商实时推荐、金融高频交易）。

• 优先动态规划：当需全局最优、问题可分解为重叠子问题且计算资源充足时（如电商物流规划、金融长期投资模型）。


## 背包问题（分数背包） 和  背包问题（0-1背包） 的区别
- ​​分数背包​​：像装沙子，抓一把性价比最高的，剩下的空间再装次优的，总能装满且价值最大。
- ​​0-1背包​​：像装家具，必须纠结“装不装得下”和“值不值得装”，需要全局计算所有可能性
- ​​一句话​​：分数背包是“精打细算的菜市场买菜”，0-1背包是“搬家时纠结带不带沙发”

### 分数背包与0-1背包的典型Top1算法题目及推导

**1. 分数背包的典型题目**
题目描述  
给定背包容量为50，物品列表如下：  
• 物品A：重量10，价值60  

• 物品B：重量20，价值100  

• 物品C：重量30，价值120  

求背包能装的最大价值（允许物品分割）。

算法选择：贪心算法（按单位价值排序）  
推导过程：  
1. 计算单位价值：  
   • 物品A：60/10 = 6  

   • 物品B：100/20 = 5  

   • 物品C：120/30 = 4  

   排序结果：A > B > C  

2. 依次装入物品：  
   • 装入物品A：剩余容量50-10=40，总价值60。  

   • 装入物品B：剩余容量40-20=20，总价值60+100=160。  

   • 装入物品C：剩余容量20，物品C的30重量只能装20/30=2/3，对应价值120*(2/3)=80。  

   总价值：60+100+80=240  

结论：最大价值为240，装入全部A、全部B和2/3的C。

---

**2. 0-1背包的典型题目**
题目描述  
给定背包容量为8，物品列表如下：  
• 物品1：重量2，价值3  

• 物品2：重量3，价值4  

• 物品3：重量4，价值5  

• 物品4：重量5，价值8  

求背包能装的最大价值（不可分割物品）。

算法选择：动态规划（二维DP表）  
推导过程：  
1. 构建DP表：  
   • 行表示物品索引（0~4），列表示背包容量（0~8）。  

   • 初始化：容量为0或物品数量为0时，价值为0。


2. 状态转移方程：  
   • 若当前物品重量 > 背包容量：继承上一行结果，即 `dp[i][j] = dp[i-1][j]`。  

   • 否则：取装或不装的最大值，即 `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)`。


3. 填表过程（部分关键步骤）：  
   | 物品/容量 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   |---|---|---|---|---|---|---|---|---|---|
   | 物品1（2,3） | 0 | 0 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |
   | 物品2（3,4） | 0 | 0 | 3 | 4 | 4 | 7 | 7 | 7 | 7 |
   | 物品3（4,5） | 0 | 0 | 3 | 4 | 5 | 7 | 8 | 9 | 9 |
   | 物品4（5,8） | 0 | 0 | 3 | 4 | 5 | 8 | 8 | 11 | 13 |  

4. 回溯解：  
   • 最大价值为13（容量8时），装入物品2（重量3）和物品4（重量5）。


---

关键对比总结
| 维度          | 分数背包                    | 0-1背包                     |
|-------------------|--------------------------------|---------------------------------|
| 典型题目       | 允许分割物品的最大价值问题 | 不可分割物品的最大价值问题 |
| 算法核心       | 贪心选择单位价值最高的物品   | 动态规划的状态转移        |
| 时间复杂度    | O(n log n)（排序主导）      | O(nW)（n为物品数，W为容量）  |
| 适用场景       | 液体、散装资源分配          | 电子产品、整件物品选择        |

通过这两个典型题目的推导，可以清晰理解两类背包问题的算法逻辑和实际应用差异。

