# 动态规划算法和贪心算法
## 两个算法的基本概念
  - 动态规划（Dynamic Programming, DP）是一种通过分解问题为子问题、存储子问题的解以避免重复计算的高效算法设计范式，其核心在于以下三个关键性质和基本组成要素
  - ​​贪心算法：每一步都选当前看起来最好的，希望通过局部最优拼出全局最优
### 动态规划:3个核心特点
  - ​​拆大问题为小问题​​：就像搭积木，把高楼分解成一层层小积木块。比如算"5层楼梯的走法"，先算1层、2层怎么走，再逐步算到5层
  - 记住算过的小问题​：准备一个笔记本（数组/字典），每次算完小积木块就记下来。比如算过"3层楼梯有3种走法"就记下，下次直接查不用重算
  - ​​小问题之间有规律​​ ：发现每层楼梯的走法 = 前1层走法 + 前2层走法。这就是递推公式：f(n) = f(n-1) + f(n-2)
  - demo：
  ```python
  dp = [0]*(n+1)
  dp[1] = 1  # 1层
  dp[2] = 2  # 2层
  for i in range(3, n+1):
    dp[i] = dp[i-1] + dp[i-2]
   ```
### 贪心算法:3个核心特点
- ​​短视选择​​：只关心眼前利益，比如找零钱时优先用最大面额的硬币（比如先给50元，再给20元），不管后面会不会有更优组合
- ​​不回头​​：一旦做出选择就不反悔，不像动态规划会保留多种可能性。比如导航选路时，贪心算法会直接走当前最快的路口，哪怕后面可能堵车
- ​​简单高效​​：适合一维问题（比如分糖果、排队问题），代码通常只有几行循环，计算速度快


## 两个算法区别和联系
动态规划的核心区别与特性

动态规划（Dynamic Programming, DP）与其他算法（尤其是贪心算法）的核心区别主要体现在以下方面：

---

1. **核心设计思想**  
动态规划通过分解问题为重叠子问题，并存储子问题的解（称为“记忆化”），避免重复计算，最终通过递推得到全局最优解。  
贪心算法则每一步只选择当前最优解，不考虑后续影响，可能导致无法得到全局最优解。

---

2. **适用场景**  
• 动态规划适用于满足以下条件的问题：  

  • 最优子结构：全局最优解包含子问题的最优解（例如背包问题、最长公共子序列）。  

  • 重叠子问题：子问题被多次重复计算（例如斐波那契数列、最短路径问题）。  

• 贪心算法仅需满足贪心选择性质（局部最优能推导全局最优），例如最小生成树、哈夫曼编码。


---

3. **实现方式对比**
---

| 特性       | 动态规划                     | 贪心算法                     |
|--------------|----------------------------|----------------------------|
| 解的质量   | 保证全局最优解            | 可能得到次优解（需问题特性支持） |
| 时间复杂度 | 较高（通常为O(n²)或更高）     | 较低（通常为O(n)或O(n log n)） |
| 空间复杂度 | 较高（需存储子问题的解）        | 较低（通常仅需常数空间）        |
| 回溯性     | 可回溯（通过存储的中间结果）     | 不可回溯（选择不可逆）         |
| 典型问题   | 背包问题、编辑距离、路径规划     | 最小生成树、活动选择、找零钱   | 



4. **关键差异举例**  
• 背包问题：  

  • 动态规划会考虑所有物品组合的可能解，通过二维表格存储子问题结果，最终找到最优解。  

  • 贪心算法可能直接按“单位价值最高”选择物品，但可能错过最优组合（例如无法处理物品不可分割的情况）。  

• 最短路径问题：  

  • 动态规划（如Floyd-Warshall算法）计算所有节点对的最短路径，时间复杂度为O(n³)，但保证准确性。  

  • 贪心算法（如Dijkstra算法）仅适用于无负权边的情况，且无法处理复杂依赖。


---

5. **总结**  
动态规划的核心优势在于系统性解决复杂问题，通过存储和复用子问题解确保全局最优；其代价是较高的计算和存储开销。  
与贪心算法相比，动态规划更适用于子问题有重叠且需全局优化的场景，而贪心算法适合局部最优可推导全局最优的简单问题。


## 两个算法分别在什么场景使用？重点讲解在电商和金融领域
贪心算法与动态规划算法对比及电商/金融场景应用

| 算法类型 | 核心原理                                                                 | 适用场景特点                                                                 | 电商领域应用场景                                                                                     | 金融领域应用场景                                                                                     |
|--------------|-----------------------------------------------------------------------------|---------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| 贪心算法 | 每一步选择当前最优解，不考虑全局最优性，但要求问题具有贪心选择性质和最优子结构 。 | 问题能通过局部最优叠加达到全局最优，且无后效性。时间复杂度低，适合实时决策场景。                                         | 1. 实时推荐系统：根据用户当前行为快速选择最优商品（如点击率最高的商品）。<br>2. 库存分配：优先分配高价值或紧俏商品，如秒杀活动库存分配。<br>3. 优惠券组合：基于用户当前购物车快速选择最优优惠组合（如满减叠加）。 | 1. 高频交易策略：快速选择当前收益最高的交易标的（如股票或期货）。<br>2. 快速止损决策：根据实时市场波动选择局部最优止损点。<br>3. 短期投资组合：在有限时间内选择收益最高的资产组合。 |
| 动态规划 | 通过分解子问题、存储中间结果（状态转移方程）和递推求解全局最优解，需满足最优子结构和重叠子问题 。 | 问题需全局最优解，子问题存在重复计算。时间/空间复杂度较高，适合离线或周期性优化场景。                                  | 1. 物流路径优化：计算多仓库协同配送的最优路径（如最小化运输成本）。<br>2. 促销策略规划：动态调整折扣力度以最大化长期利润（如考虑库存成本和用户购买行为）。<br>3. 库存动态管理：多周期库存补货策略优化（如考虑需求波动和仓储成本）。 | 1. 投资组合优化：长期资产配置中平衡风险与收益（如Markowitz模型）。<br>2. 期权定价：通过状态转移方程计算期权价值（如Black-Scholes模型）。<br>3. 风险模型构建：动态评估市场风险（如VaR计算）。 |

---

核心差异总结
| 对比维度       | 贪心算法                                                                 | 动态规划                                                                 |
|--------------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 最优解保证      | 局部最优，可能无法全局最优 。                                           | 全局最优（需满足最优子结构）。                                          |
| 时间复杂度      | 通常为O(n)或O(n log n)，适合实时处理 。                                 | 通常为O(n²)或更高，适合离线计算 。                                       |
| 空间复杂度      | 低（仅需存储当前状态）。                                               | 高（需存储中间状态表）。                                               |
| 典型问题        | 最小生成树（Prim算法）、背包问题（分数背包）、活动选择 。               | 背包问题（0-1背包）、最长公共子序列、最短路径（Floyd算法）。            |
| 适用领域侧重    | 实时性要求高、局部决策影响显著的场景（如电商秒杀、金融高频交易）。       | 需全局优化、多阶段决策的场景（如电商物流规划、金融长期投资）。         |

---

电商与金融场景深度解析
1. **电商场景**
• 贪心算法：  

  • 案例：在“双十一”大促中，系统需实时调整优惠券组合。贪心算法可快速筛选出当前用户购物车中“满500减100”叠加“品类券”的最优组合，而无需考虑后续可能的更高折扣。

  • 局限性：若优惠规则复杂（如跨品类满减），贪心策略可能错过全局最优解。


• 动态规划：  

  • 案例：物流中心需规划全国仓库的协同配送路径，动态规划通过状态转移方程计算各节点间的最短路径，结合实时交通数据更新策略。

  • 优势：在多约束（如车辆载重、时间窗口）下仍能保证全局最优。


2. **金融场景**
• 贪心算法：  

  • 案例：高频交易中，算法需在毫秒级选择当前市场最优报价（如最优买一价），贪心策略可快速匹配订单。

  • 风险：在极端市场波动下，局部最优可能导致连锁亏损。


• 动态规划：  

  • 案例：构建长期养老基金组合时，动态规划通过递归计算不同资产配比的风险-收益曲线，选择夏普比率最高的方案。

  • 扩展：结合蒙特卡洛模拟，动态规划可评估极端市场情景下的资产抗风险能力。


---

选择建议
• 优先贪心算法：当问题满足贪心性质、实时性要求高且允许次优解时（如电商实时推荐、金融高频交易）。

• 优先动态规划：当需全局最优、问题可分解为重叠子问题且计算资源充足时（如电商物流规划、金融长期投资模型）。


## 背包问题（分数背包） 和  背包问题（0-1背包） 的区别
- ​​分数背包​​：像装沙子，抓一把性价比最高的，剩下的空间再装次优的，总能装满且价值最大。
- ​​0-1背包​​：像装家具，必须纠结“装不装得下”和“值不值得装”，需要全局计算所有可能性
- ​​一句话​​：分数背包是“精打细算的菜市场买菜”，0-1背包是“搬家时纠结带不带沙发”

### 分数背包与0-1背包的典型Top1算法题目及推导

**1. 分数背包的典型题目**
题目描述  
给定背包容量为50，物品列表如下：  
• 物品A：重量10，价值60  

• 物品B：重量20，价值100  

• 物品C：重量30，价值120  

求背包能装的最大价值（允许物品分割）。

算法选择：贪心算法（按单位价值排序）  
推导过程：  
1. 计算单位价值：  
   • 物品A：60/10 = 6  

   • 物品B：100/20 = 5  

   • 物品C：120/30 = 4  

   排序结果：A > B > C  

2. 依次装入物品：  
   • 装入物品A：剩余容量50-10=40，总价值60。  

   • 装入物品B：剩余容量40-20=20，总价值60+100=160。  

   • 装入物品C：剩余容量20，物品C的30重量只能装20/30=2/3，对应价值120*(2/3)=80。  

   总价值：60+100+80=240  

结论：最大价值为240，装入全部A、全部B和2/3的C。

---

**2. 0-1背包的典型题目**
题目描述  
给定背包容量为8，物品列表如下：  
• 物品1：重量2，价值3  

• 物品2：重量3，价值4  

• 物品3：重量4，价值5  

• 物品4：重量5，价值8  

求背包能装的最大价值（不可分割物品）。

算法选择：动态规划（二维DP表）  
推导过程：  
1. 构建DP表：  
   • 行表示物品索引（0~4），列表示背包容量（0~8）。  

   • 初始化：容量为0或物品数量为0时，价值为0。


2. 状态转移方程：  
   • 若当前物品重量 > 背包容量：继承上一行结果，即 `dp[i][j] = dp[i-1][j]`。  

   • 否则：取装或不装的最大值，即 `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)`。


3. 填表过程（部分关键步骤）：  
   | 物品/容量 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
   |---|---|---|---|---|---|---|---|---|---|
   | 物品1（2,3） | 0 | 0 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |
   | 物品2（3,4） | 0 | 0 | 3 | 4 | 4 | 7 | 7 | 7 | 7 |
   | 物品3（4,5） | 0 | 0 | 3 | 4 | 5 | 7 | 8 | 9 | 9 |
   | 物品4（5,8） | 0 | 0 | 3 | 4 | 5 | 8 | 8 | 11 | 13 |  

4. 回溯解：  
   • 最大价值为13（容量8时），装入物品2（重量3）和物品4（重量5）。


---

关键对比总结
| 维度          | 分数背包                    | 0-1背包                     |
|-------------------|--------------------------------|---------------------------------|
| 典型题目       | 允许分割物品的最大价值问题 | 不可分割物品的最大价值问题 |
| 算法核心       | 贪心选择单位价值最高的物品   | 动态规划的状态转移        |
| 时间复杂度    | O(n log n)（排序主导）      | O(nW)（n为物品数，W为容量）  |
| 适用场景       | 液体、散装资源分配          | 电子产品、整件物品选择        |

通过这两个典型题目的推导，可以清晰理解两类背包问题的算法逻辑和实际应用差异。


### ​​DP表的物理意义与设计​​
- 定义​​：dp[i][j]表示​​前i个物品​​在​​背包容量为j​​时的最大价值。
- ​​行（i）​​：物品的决策阶段（从0到n，0表示无物品）。
- ​​列（j）​​：背包容量（从0到W）
- 状态转移方程的逐层拆解​
  1.​​不选第i个物品​​：dp[i][j] = dp[i-1][j]
  2.选第i个物品​​：dp[i][j] = dp[i-1][j-w[i]] + v[i]

## java代码实现
Java实现0-1背包问题（含物品选择输出）

以下是基于动态规划的Java代码实现，能够计算背包最大价值并输出具体选择的物品编号（从1开始计数）。代码逻辑结合了动态规划表构建和回溯选择过程。

---

1. **完整代码实现**
```java
import java.util.ArrayList;
import java.util.Collections;

public class Knapsack01WithSelection {

    public static void main(String[] args) {
        int[] values = {3, 4, 5, 7};  // 物品价值数组
        int[] weights = {2, 3, 4, 5}; // 物品重量数组
        int capacity = 9;             // 背包容量

        Result result = knapsackWithSelection(values, weights, capacity);
        System.out.println("最大价值: " + result.maxValue);
        System.out.println("选中的物品编号: " + result.selectedItems);
        System.out.println("总重量: " + result.totalWeight);
    }

    public static Result knapsackWithSelection(int[] values, int[] weights, int capacity) {
        int n = values.length;
        int[][] dp = new int[n + 1][capacity + 1];
        ArrayList<Integer> selected = new ArrayList<>();

        // 1. 填充动态规划表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= capacity; j++) {
                if (j >= weights[i - 1]) {
                    dp[i][j] = Math.max(
                        dp[i - 1][j],
                        dp[i - 1][j - weights[i - 1]] + values[i - 1]
                    );
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // 2. 回溯选中的物品
        int remainingCap = capacity;
        for (int i = n; i > 0; i--) {
            if (dp[i][remainingCap] != dp[i - 1][remainingCap]) {
                selected.add(i); // 物品编号从1开始
                remainingCap -= weights[i - 1];
            }
        }
        Collections.sort(selected); // 按从小到大排序

        // 计算总重量
        int totalWeight = selected.stream().mapToInt(i -> weights[i - 1]).sum();

        return new Result(dp[n][capacity], selected, totalWeight);
    }

    static class Result {
        int maxValue;
        ArrayList<Integer> selectedItems;
        int totalWeight;

        public Result(int maxValue, ArrayList<Integer> selectedItems, int totalWeight) {
            this.maxValue = maxValue;
            this.selectedItems = selectedItems;
            this.totalWeight = totalWeight;
        }
    }
}
```

---

2. **关键步骤解析**
1. 动态规划表构建  
   • 使用二维数组 `dp[i][j]` 表示前 `i` 个物品在容量 `j` 下的最大价值。

   • 状态转移方程：  

     ```java
     if (j >= weights[i-1]) {
         dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1]);
     } else {
         dp[i][j] = dp[i-1][j];
     }
     ```

2. 回溯选中物品  
   • 从最后一个物品和最大容量开始逆推，若当前行与上一行价值不同，则说明该物品被选中。

   • 更新剩余容量 `remainingCap` 并记录选中的物品编号（从1开始）。


3. 结果输出  
   • 返回包含最大价值、选中物品编号和总重量的结果对象。


---

3. **测试示例**
输入：
```java
values = {3, 4, 5, 7};  // 对应物品1~4的价值
weights = {2, 3, 4, 5}; // 对应物品1~4的重量
capacity = 9;
```
输出：
```
最大价值: 12
选中的物品编号: [1, 4]
总重量: 7 (2+5)
```

---

4. **优化与扩展**
• 空间优化：可用一维数组代替二维数组（倒序遍历容量），减少空间复杂度至O(W)。

• 路径记录优化：若需频繁查询选中物品，可额外维护一个布尔数组记录选择路径。


通过此实现，可以清晰理解动态规划在0-1背包问题中的应用，并灵活调整以满足实际需求。



###​​ 买卖股票的最佳时机（LeetCode 121）
- 题目：LeetCode 121. 买卖股票的最佳时机​​，给定一个数组 prices，其中 prices[i] 表示某支股票第 i 天的价格。你只能选择​​某一天​​买入，并在​​未来的某一天​​卖出。设计算法计算最大利润。若无法获利，返回
  #### ​​贪心算法：核心思想​​：在遍历过程中，记录历史最低买入价，并计算当前价格与历史最低价的差值（即利润），最终取最大值
  ```java
  public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) return 0;
        
        int minPrice = prices[0];
        int maxProfit = 0;
        int buyDay = 1, sellDay = 0; // 天数从 1 开始计数
        
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] < minPrice) {
                minPrice = prices[i];
                buyDay = i + 1; // 更新买入天（i 是数组索引，天数需 +1）
            } else {
                int currentProfit = prices[i] - minPrice;
                if (currentProfit > maxProfit) {
                    maxProfit = currentProfit;
                    sellDay = i + 1; // 记录卖出天
                }
            }
        }
        
        // 输出结果（若未交易则返回 0）
        System.out.println("买入天: " + (maxProfit > 0 ? buyDay : 0));
        System.out.println("卖出天: " + (maxProfit > 0 ? sellDay : 0));
        return maxProfit;
    }
}````

####动态规划算法， ​​核心思想​​：通过状态转移方程记录每一天的两种状态（持有股票/不持有股票）下的最大利润
```java
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) return 0;
        
        int n = prices.length;
        int[][] dp = new int[n][2];
        int[] buyDay = new int[n]; // 记录每天持有股票时的买入天
        
        // 初始化
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        buyDay[0] = 1; // 第 1 天买入
        
        for (int i = 1; i < n; i++) {
            // 不持有股票：前一天不持有，或当天卖出
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            
            // 持有股票：前一天持有，或当天买入
            if (dp[i-1][1] > -prices[i]) {
                dp[i][1] = dp[i-1][1];
                buyDay[i] = buyDay[i-1]; // 保持之前的买入天
            } else {
                dp[i][1] = -prices[i];
                buyDay[i] = i + 1; // 记录当前买入天（天数从 1 开始）
            }
        }
        
        // 回溯找到卖出天
        int maxProfit = dp[n-1][0];
        int sellDay = 0;
        for (int i = n-1; i >= 0; i--) {
            if (dp[i][0] == maxProfit && dp[i][0] != dp[i-1][0]) {
                sellDay = i + 1; // 找到最后一次卖出的天
                break;
            }
        }
        
        // 输出结果（若未交易则返回 0）
        System.out.println("买入天: " + (maxProfit > 0 ? buyDay[sellDay-1] : 0));
        System.out.println("卖出天: " + (maxProfit > 0 ? sellDay : 0));
        return maxProfit;
    }
}
````


