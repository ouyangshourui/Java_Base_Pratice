## 锁的分类



### Java锁的分类及依据
### Java锁的分类、优缺点及依据

| **分类维度**          | **类型**                | **依据/特性**                                                                 | **例子**                                                                 | **优点**                                                                 | **缺点**                                                                 |
|-----------------------|-------------------------|------------------------------------------------------------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| **实现方式**          | 内置锁（隐式锁）        | JVM直接支持，通过关键字实现                                                   | `synchronized`                                                           | 自动管理锁，避免手动释放；代码简洁                                       | 功能有限（如不支持公平锁、不可中断）                                     |
|                       | 显式锁                  | 基于API手动实现锁                                                            | `ReentrantLock`、`StampedLock`                                           | 灵活性强（支持公平锁、可中断、超时等）                                   | 需手动释放锁，易因遗漏导致死锁                                           |
| **可重入性**          | 可重入锁                | 同一线程可重复获取锁                                                         | `synchronized`、`ReentrantLock`                                          | 避免嵌套锁死锁；支持递归调用                                             | 轻微性能开销                                                             |
|                       | 不可重入锁              | 同一线程多次获取同一锁会阻塞                                                 | 早期简单`Lock`实现                                                        | 实现简单                                                               | 易因递归调用导致死锁                                                     |
| **公平性**            | 公平锁                  | 按请求顺序分配锁                                                             | `ReentrantLock(true)`                                                    | 防止线程饥饿                                                           | 吞吐量低（需维护队列）；响应延迟                                         |
|                       | 非公平锁                | 允许插队竞争锁                                                               | `synchronized`、`ReentrantLock()`（默认）                                 | 高吞吐量（减少线程切换）                                               | 可能导致线程饥饿                                                         |
| **共享性**            | 排他锁（写锁）          | 仅一个线程持有锁                                                             | `synchronized`、`ReentrantLock`                                          | 保证数据一致性                                                         | 并发度低（读写互斥）                                                     |
|                       | 共享锁（读锁）          | 允许多线程同时读                                                             | `ReentrantReadWriteLock.ReadLock`                                        | 提高读并发性能                                                         | 写操作需等待所有读锁释放，可能写饥饿                                     |
| **并发策略**          | 悲观锁                  | 假设冲突必然发生，提前加锁                                                   | `synchronized`、`ReentrantLock`                                          | 保证强一致性                                                           | 高锁竞争时性能差                                                         |
|                       | 乐观锁                  | 假设无冲突，提交时检测                                                       | CAS（如`AtomicInteger`）、`StampedLock`                                  | 无锁竞争时性能高                                                       | 冲突时需重试，可能CPU空转                                                |
| **锁状态升级（JVM）** | 偏向锁                  | 单线程无竞争优化                                                             | JVM自动优化                                                              | 无竞争时性能接近无锁                                                   | 多线程竞争时需撤销偏向，额外开销                                         |
|                       | 轻量级锁                | 低竞争时CAS自旋                                                              | JVM自动优化                                                              | 减少线程阻塞（自旋短暂等待）                                           | 自旋过长浪费CPU                                                          |
|                       | 重量级锁                | 高竞争时阻塞线程                                                             | JVM自动优化                                                              | 避免CPU空转                                                            | 线程切换开销大                                                           |
| **其他特殊锁**        | 自旋锁                  | 失败时循环重试                                                               | `synchronized`中的自适应自旋                                             | 减少上下文切换（适合短耗时操作）                                       | 长时间自旋浪费CPU                                                        |
|                       | 分段锁                  | 资源分片独立加锁                                                             | `ConcurrentHashMap`分段设计                                              | 提高并发吞吐量                                                         | 实现复杂；需权衡分片粒度                                                 |

### 否分布式锁，是公平锁、是否共享、是否悲观 选择流程图
# Java锁技术选型决策流程图（Markdown兼容版）

## 1. 是否需要分布式锁？
### 是 → 进入分布式锁决策分支
  - **强一致性要求？**
    - 是
      - **已有ZooKeeper集群？**
        - 是 → `ZooKeeper锁`
          - 技术特点：顺序节点+Watch机制，公平锁，CP系统
          - 代码示例：`Curator的InterProcessMutex`
        - 否 → 
          - **需要自行实现Raft协议？**
            - 是 → `基于Raft实现`
              - 技术特点：强一致，需实现日志复制和选举
            - 否 → `Etcd锁`
              - 技术特点：基于Raft的KV存储，Lease续约机制
    - 否 → 
      - **高性能优先？**
        - 是 → `Redis锁`
          - 技术特点：Redisson RedLock，非公平锁，AP系统
        - 否 → `数据库锁`
          - 技术特点：唯一约束/版本号，注意连接池消耗

### 否 → 进入本地锁决策流程
  - **需要共享锁？**
    - 是 → `ReadWriteLock/StampedLock`
    - 否 → 
      - **需要悲观锁？**
        - 是 → 
          - **需要公平性？**
            - 是 → `ReentrantLock(true)`
            - 否 → `synchronized`
        - 否 → `Atomic原子类`

## 2. 主流方案对比表
| 方案           | 核心技术           | 一致性      | 性能  | 实现复杂度 | 典型场景                |
|----------------|--------------------|-------------|-------|------------|-------------------------|
| ZooKeeper锁    | 顺序节点+Watcher   | 强一致(CP)  | 中    | 中         | 金融交易，CP系统        |
| Raft实现锁     | 日志复制+选举      | 强一致      | 低    | 高         | 自研分布式系统          |
| Etcd锁         | Lease+Revision     | 线性一致    | 中高  | 低         | Kubernetes生态          |
| Redis锁        | SETNX+Redisson     | 最终一致(AP)| 高    | 低         | 电商秒杀，AP系统        |
| 数据库锁       | 唯一约束/版本号    | 依赖实现    | 低    | 低         | 低并发且已有DB场景      |

## 3. 关键选择逻辑
```text
ZooKeeper锁 → 当需要严格顺序性（如分布式事务协调）
Raft锁 → 需要完全自主控制协议时选择
Etcd锁 → Kubernetes生态优先选
Redis锁 → 高并发AP系统首选
数据库锁 → 无中间件时的兜底方案
