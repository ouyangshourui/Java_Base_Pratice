# 一致性模型与Java锁综合指南

## 一致性模型对比表（含业务场景与Java锁实现）
| 对比维度         | 强一致性 (Strong)                          | 最终一致性 (Eventual)                     |
|------------------|--------------------------------------------|--------------------------------------------|
| **数据时效性**   | 立即可见                                   | 延迟可见（秒级~分钟级）                    |
| **性能吞吐**     | 1k-5k TPS                                 | 50k-1M+ TPS                               |
| **实现复杂度**   | 2PC/Paxos/分布式锁                         | MQ/CRDT/版本向量                           |
| **业务场景**     | 银行转账/证券交易/库存扣减                  | 社交点赞/用户行为分析/日志聚合             |
| **Java锁实现**   | `ReentrantLock`/`synchronized`/`Redisson` | `StampedLock`/`ReadWriteLock`/`LongAdder` |
| **容错机制**     | 同步阻塞+事务回滚                          | 异步重试+补偿事务                          |
| **资源消耗**     | 高（CPU 30%-50%）                          | 低（CPU 5%-15%）                          |

---

## Java锁选择决策树（含一致性要求）
```mermaid
graph TD
    Start{需要数据强一致性?}
    Start -->|是| Strong[强一致性锁选择]
    Start -->|否| Eventual[最终一致性机制]
    
    Strong --> Atomic{原子操作要求}
    Atomic -->|简单同步| Sync[synchronized]
    Atomic -->|复杂控制| Reentrant[ReentrantLock]
    Reentrant --> Fair{需要公平性?}
    Fair -->|是| FairLock[new ReentrantLock(true)]
    Fair -->|否| NonFair[new ReentrantLock()]
    
    Strong --> Distributed{分布式系统?}
    Distributed -->|是| RedisLock[Redisson分布式锁]
    Distributed -->|否| LocalLock[本地锁]
    
    Eventual --> Concurrency{并发特征}
    Concurrency -->|读多写少| Stamped[StampedLock乐观读]
    Concurrency -->|写多读少| ReadWrite[ReadWriteLock]
    Concurrency -->|计数统计| Adder[LongAdder分段计数]
    
    classDef strong fill:#fdd,stroke:#f44;
    classDef eventual fill:#dfd,stroke:#4f4;
    class Strong,RedisLock,FairLock strong;
    class Eventual,Stamped,ReadWrite eventual;
